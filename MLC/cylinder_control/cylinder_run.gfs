# Gerris Flow Solver 2D version 1.3.2 (131206-12345)
8 10 GfsSimulation GfsBox GfsGEdge { rootlevel = 1 x = -0.25 y = -0.25 version = 131206 } {
  GModule controller
  GfsGlobal {
static const double Re = 235;
static const double R = 0.5;
static const double Ut = 1;
static const double ACT_THETA_CENTER = 0.375*M_PI;  /* 3/8* pi */
static const double ACT_THETA_WIDTH = 0.125*M_PI; /*  pi/8 */
static const double ACT_SIGMA_COEF = 0.75;
static const double REFINE_MIN = 4;
static const double REFINE_MAX = 7;
static const double REFINE_SOLID_MAX = 8;
static const double T_SIZE = 0.2;
static const double T_CONCENTRATION = 1;

static double actuator_degrees(double x, double y) {
    return atan2(y, x);
}

static double gaussian_curve(float degrees) {
    static const float mu = ACT_THETA_CENTER;
    static const float sigma = ACT_SIGMA_COEF * (ACT_THETA_WIDTH / 2.0);
    if (degrees < 0)
        degrees = -degrees;
    float aux = (degrees - mu) / sigma;
    return 1 * exp(-0.5 * aux * aux);
}

static double degrees_in_range(float degrees){
    static const float degrees_min = ACT_THETA_CENTER - ACT_THETA_WIDTH / 2.0;
    static const float degrees_max = ACT_THETA_CENTER + ACT_THETA_WIDTH / 2.0;

    if (degrees < 0)
        degrees = -degrees;
    return degrees >= degrees_min && degrees <= degrees_max;
}

static double actuation_u(double x, double y) {
    double degrees = actuator_degrees(x, y);
    if (degrees_in_range(degrees)) {
        float act = gaussian_curve(degrees) * controller("actuation");
        return (degrees > 0) ? y*act : -y*act;
    }
    else
        return 0;
}
static double actuation_v(double x, double y) {
    double degrees = actuator_degrees(x, y);
    if (degrees_in_range(degrees)) {
        float act = gaussian_curve(degrees) * controller("actuation");
        return (degrees > 0) ? -x*act : x*act;
    }
    else
        return 0;
}
static int symmetric_refinement(double x, double y) {
    return (1 - fabs(2*y/10)) * (REFINE_MAX - REFINE_MIN) + REFINE_MIN;
}
static int positive_quad_symmetric_refinement(double x, double y) {
    double yAbs = fabs(y);
    return (REFINE_MAX-REFINE_MIN)*(2*yAbs/10 - 1)*(2*yAbs/10 - 1) + REFINE_MIN;
}
static int negative_quad_symmetric_refinement(double x, double y) {
    return -(REFINE_MAX-REFINE_MIN)*(2*y/10)*(2*y/10) + REFINE_MAX;
}


  }
  GfsTime { i = 0 t = 0 end = 60 dtmax = 0.025 }
  GfsRefineSolid REFINE_SOLID_MAX
  GfsSolid { istep = 1073741823 } ( x*x + y*y - R*R ) {}
  GfsControllerSolidForce { step = 0.025 }
  GfsVariableTracer { istep = 1 } T {
  cfl      = 0.8
  gradient = gfs_center_van_leer_gradient
  flux     = gfs_face_advection_flux
  average  = 0
  scheme   = godunov
}
  GfsSourceDiffusion { istep = 1 } T 0.025 {
  tolerance = 1e-06
  nrelax    = 4
  erelax    = 1
  minlevel  = 0
  nitermax  = 100
  nitermin  = 1
  weighted  = 0
  beta      = 1
}
  GfsEventBalance { istep = 10 } 0.1
  GfsSourceViscosity { istep = 1 } 1./Re {
  tolerance = 1e-06
  nrelax    = 4
  erelax    = 1
  minlevel  = 0
  nitermax  = 100
  nitermin  = 1
  weighted  = 0
  beta      = 1
}
  GfsAdaptFunction { istep = 5 } { minlevel = (x < 0 ? positive_quad_symmetric_refinement(x, y) : REFINE_MIN) maxlevel = (x < 0 ? positive_quad_symmetric_refinement(x, y) : REFINE_MAX) cmax = 0.1 } T
  GfsOutputTime { step = 1 } stdout
  GfsOutputSolidForce { step = 0.025 } results/forces.txt
  GfsOutputSimulation { step = 10 } results/cylinder_%07.3f.gfs { variables = U,V,P,T binary = 0 }
  GfsOutputLocation { step = 0.025 } results/sensors.txt {
3 1 0
3 -1 0
4 1 0
4 -1 0
5 1 0
5 -1 0
6 1 0
6 -1 0
}
  GfsControllerLocation { step = 0.025 } {
  python-main= "./python/main.py"
  python-userscript = "./python/user/controller.py"
  samples-window = 99
} {
3 1 0
3 -1 0
4 1 0
4 -1 0
5 1 0
5 -1 0
6 1 0
6 -1 0
}
  GfsOutputPPM { step = 0.25 } { ppm2mpeg -s 1024x512 > vorticity.mpg } { v =  Vorticity min = -10 max = 10 }
  GfsOutputPPM { step = 0.25 } { ppm2mpeg -s 1024x512 > tracer.mpg } { v =  T min = 0 max = 1 }
  GfsSurfaceBc U Dirichlet {
      return actuation_u(x, y);
  }
  GfsSurfaceBc V Dirichlet {
      return actuation_v(x, y);
  }
  GfsPhysicalParams { g = 1 L = 10 }
  GfsAdvectionParams {
  cfl      = 0.8
  gradient = gfs_center_gradient
  flux     = gfs_face_velocity_advection_flux
  average  = 1
  scheme   = godunov
}
  GfsApproxProjectionParams {
  tolerance = 0.001
  nrelax    = 4
  erelax    = 1
  minlevel  = 0
  nitermax  = 100
  nitermin  = 1
  weighted  = 0
  beta      = 1
}
  GfsProjectionParams {
  tolerance = 0.001
  nrelax    = 4
  erelax    = 1
  minlevel  = 0
  nitermax  = 100
  nitermin  = 1
  weighted  = 0
  beta      = 1
}
}
GfsBox { id = 1 pid = 2 size = 1 x = -0.25 y = -0.25 z = 0 left = GfsBoundary {
GfsBcDirichlet T { return (fabs(y) < T_SIZE/2.0) ? T_CONCENTRATION : 0.; }
GfsBcDirichlet U Ut
GfsBcDirichlet V 0
} }
GfsBox { id = 2 pid = 0 size = 1 x = -0.25 y = 0.25 z = 0 left = GfsBoundary {
GfsBcDirichlet T { return (fabs(y) < T_SIZE/2.0) ? T_CONCENTRATION : 0.; }
GfsBcDirichlet U Ut
GfsBcDirichlet V 0
} }
GfsBox { id = 3 pid = 1 size = 1 x = 0.25 y = 0.25 z = 0 }
GfsBox { id = 4 pid = 3 size = 1 x = 0.25 y = -0.25 z = 0 }
GfsBox { id = 5 pid = 1 size = 1 x = 0.75 y = 0.25 z = 0 }
GfsBox { id = 6 pid = 0 size = 1 x = 1.25 y = 0.25 z = 0 right = GfsBoundaryOutflow }
GfsBox { id = 7 pid = 3 size = 1 x = 0.75 y = -0.25 z = 0 }
GfsBox { id = 8 pid = 2 size = 1 x = 1.25 y = -0.25 z = 0 right = GfsBoundaryOutflow }
2 1 bottom
1 4 right
2 3 right
5 3 left
3 4 bottom
7 4 left
5 6 right
5 7 bottom
6 8 bottom
7 8 right
